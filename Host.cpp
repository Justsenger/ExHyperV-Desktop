#define WIN32_LEAN_AND_MEAN
#define HV_PROTOCOL_RAW 1

#include <WinSock2.h>
#include <WS2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <combaseapi.h>
#include <vector>
#pragma comment(lib, "Ws2_32.lib")
#include <fstream>
#include <Windows.h>

std::vector<BYTE> g_imageData;  // 存储全局的图像数据

void DisplayImage(HDC hdc, const std::vector<BYTE>& imageData, int imageWidth, int imageHeight, int windowWidth, int windowHeight) {
    BITMAPINFOHEADER bmiHeader = { sizeof(BITMAPINFOHEADER), imageWidth, imageHeight, 1, 32 };
    BITMAPINFO bmi = { bmiHeader, { 0 } };

    // 设置高质量缩放模式
    SetStretchBltMode(hdc, HALFTONE);  // 设置为 HALFTONE 模式以获得更好的缩放效果

    // 使用 StretchDIBits 绘制图像，按窗口大小缩放
    StretchDIBits(hdc, 0, 0, windowWidth, windowHeight, 0, 0, imageWidth, imageHeight,
        imageData.data(), &bmi, DIB_RGB_COLORS, SRCCOPY);
}



LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
    switch (msg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_PAINT: {
        // 获取绘制上下文 (HDC)
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);  // 获取当前窗口的 HDC
        EndPaint(hwnd, &ps);
    }
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wp, lp);  // 默认处理其他消息
    }
}


struct SOCKADDR_HV
{
    ADDRESS_FAMILY Family;
    USHORT Reserved;
    GUID VmId;
    GUID ServiceId;
};

DEFINE_GUID(HV_GUID_PARENT,
    0xa42e7cda, 0xd03f, 0x480c, 0x9c, 0xc2, 0xa, 0x4, 0xde, 0x20, 0xab, 0xb8, 0x78);
DEFINE_GUID(HV_GUID_ZERO,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);


#define RECEIVE_BUFFER_SIZE (8 * 1024 * 1024)  // 8MB 缓冲区大小

// 设置接收缓冲区大小
void SetSocketBufferSize(SOCKET ClientSocket) {
    int bufferSize = RECEIVE_BUFFER_SIZE;
    setsockopt(ClientSocket, SOL_SOCKET, SO_RCVBUF, (const char*)&bufferSize, sizeof(bufferSize));
}

void PrintSocketBufferSize(SOCKET ClientSocket) {
    int bufferSize = 0;
    int sizeLen = sizeof(bufferSize);
    if (getsockopt(ClientSocket, SOL_SOCKET, SO_RCVBUF, (char*)&bufferSize, &sizeLen) == SOCKET_ERROR) {
        printf("获取缓冲区大小失败，错误代码：%d\n", WSAGetLastError());
    }
    else {
        printf("当前接收缓冲区大小: %d bytes\n", bufferSize);
    }
}



std::vector<BYTE> ReceiveImage(SOCKET ClientSocket) {
    // 接收图像数据的大小
    size_t imageSize = 0;
    // 设置接收缓冲区大小为8MB
    //SetSocketBufferSize(ClientSocket);
    //PrintSocketBufferSize(ClientSocket);

    int iResult = recv(ClientSocket, (char*)&imageSize, sizeof(imageSize), 0);
    if (iResult <= 0) {
        printf("接收图像大小失败，错误代码：%d\n", WSAGetLastError());
        return {};
    }

    // 调试：打印接收到的图像大小
    // printf("接收的图像大小: %zu 字节\n", imageSize);

    // 创建一个足够大的缓冲区来接收完整的图像数据
    std::vector<BYTE> imageData(imageSize);
    size_t totalBytesReceived = 0;

    // 分批接收图像数据
    while (totalBytesReceived < imageSize) {
        // 每次尽量接收大的数据块
        iResult = recv(ClientSocket, (char*)(imageData.data() + totalBytesReceived),
            imageSize - totalBytesReceived, 0);

        if (iResult == SOCKET_ERROR) {
            printf("接收图像数据失败，错误代码：%d\n", WSAGetLastError());
            return {};
        }

        totalBytesReceived += iResult;

        // 调试：显示接收到的字节数
         printf("接收到 %zu/%zu 字节\n", totalBytesReceived, imageSize);
    }

    // printf("成功接收完整图像数据，总字节数：%zu\n", totalBytesReceived);

    return imageData;
}


int main() {
    WSADATA wsaData;
    SOCKADDR_HV clientService;

    // 指定注册服务的GUID
    CLSID ServiceID;
    const wchar_t* clsid_str = L"{1f6be6bc-3e37-4d4a-97e3-46e7a5bdf739}";
    CLSIDFromString(clsid_str, &ServiceID); // GUID of Service, generated by powershell

    // 初始化 Winsock
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0)
    {
        printf("Winsock初始化失败：%d\n", iResult);
        return 1;
    }
    struct addrinfo* result = NULL,
        hints;

    CONST GUID* serviceId = &ServiceID;

    ZeroMemory(&clientService, sizeof(clientService));
    clientService.Family = AF_HYPERV;
    clientService.VmId = HV_GUID_ZERO;
    clientService.ServiceId = *serviceId;

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_HYPERV;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = HV_PROTOCOL_RAW;
    hints.ai_addrlen = sizeof(SOCKADDR_HV);
    hints.ai_addr = reinterpret_cast<SOCKADDR*>(&clientService);

    SOCKET ListenSocket = INVALID_SOCKET;

    // 创建接口以监听客户端连接
    ListenSocket = socket(hints.ai_family, hints.ai_socktype, hints.ai_protocol);
    if (ListenSocket == INVALID_SOCKET)
    {
        printf("接口创建失败： %d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    // Setup the TCP listening socket
    iResult = bind(ListenSocket, hints.ai_addr, (int)hints.ai_addrlen);
    if (iResult == SOCKET_ERROR)
    {
        printf("bind failed: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }

    // To listen on a socket
    if (listen(ListenSocket, SOMAXCONN) == SOCKET_ERROR)
    {
        printf("listen failed: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }

    SOCKET ClientSocket;
    ClientSocket = INVALID_SOCKET;

    while (true) { // This loop ensures the server keeps running and waiting for new connections.
        printf("等待客户端连接...\n");
        

        // Accept a client connection and display connection message
        ClientSocket = accept(ListenSocket, NULL, NULL);
        if (ClientSocket == INVALID_SOCKET)
        {
            printf("accept failed: %d\n", WSAGetLastError());
            closesocket(ListenSocket);
            WSACleanup();
            return 1;
        }

        printf("客户端连接成功!\n");




        int width=0, height = 0, imageSize = 0;

        // 接收宽度
        int iResult = recv(ClientSocket, (char*)&width, sizeof(width), 0);
        if (iResult == SOCKET_ERROR) {
            printf("接收宽度失败: %d\n", WSAGetLastError());
            return false;
        }
        else {
            printf("接收宽度: %d\n", width);
        }

        // 接收高度
        iResult = recv(ClientSocket, (char*)&height, sizeof(height), 0);
        if (iResult == SOCKET_ERROR) {
            printf("接收高度失败: %d\n", WSAGetLastError());
            return false;
        }
        else {
            printf("接收高度: %d\n", height);
        }

        // 接收图像大小
        iResult = recv(ClientSocket, (char*)&imageSize, sizeof(imageSize), 0);
        if (iResult == SOCKET_ERROR) {
            printf("接收图像大小失败: %d\n", WSAGetLastError());
            return false;
        }
        else {
            printf("接收图像大小: %d\n", imageSize);
        }

        printf("接收到协商信息：宽度 = %d, 高度 = %d, 图像大小 = %d\n", width, height, imageSize);

        // 发送确认信息给客户端
        const char* confirmMsg = "协商成功，开始接收图像数据";
        iResult = send(ClientSocket, confirmMsg, strlen(confirmMsg), 0);
        if (iResult == SOCKET_ERROR) {
            printf("发送确认信息失败: %d\n", WSAGetLastError());
            return false;
        }



        // 缩小后的窗口尺寸
        int windowWidth = static_cast<int>(width * 0.8);  // 计算0.8倍的宽度
        int windowHeight = static_cast<int>(height * 0.8); // 计算0.8倍的高度

        WNDCLASS wc = {};
        wc.lpfnWndProc = WndProc;     // 窗口过程
        wc.hInstance = GetModuleHandle(NULL);
        wc.lpszClassName = L"ServerWindowClass";
        RegisterClass(&wc);

        // 创建窗口
        HWND hwnd = CreateWindowEx(
            0, L"ServerWindowClass", L"Server Screen", WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, windowWidth, windowHeight,   // 调整为适当的窗口大小
            NULL, NULL, wc.hInstance, NULL);
        HDC hdc = GetDC(hwnd);

        // 显示窗口
        ShowWindow(hwnd, SW_SHOWNORMAL);
        UpdateWindow(hwnd);


        int imageCount = 0; // 变量，用于跟踪已接收的完整图像数量


        MSG msg;


        while (true) {


            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                if (msg.message == WM_QUIT)
                    break;
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }


            // 接收图像数据
            std::vector<BYTE> imageData = ReceiveImage(ClientSocket);
            if (imageData.empty()) {
                printf("接收图像失败或客户端断开连接\n");
                break; // 如果接收失败或连接关闭，退出
            }

            // 显示接收到的图像
            //printf("显示接收到的图像\n");


            // 获取客户区的宽度和高度
            RECT clientRect;
            GetClientRect(hwnd, &clientRect);

            // 获取客户区的宽度和高度
            int clientWidth = clientRect.right - clientRect.left;
            int clientHeight = clientRect.bottom - clientRect.top;

            InvalidateRect(hwnd, NULL, TRUE);  // 强制刷新窗口
            // 调用 DisplayImage 函数，传入客户区的宽高
            DisplayImage(hdc, imageData, width, height, clientWidth, clientHeight);

            // 发送确认消息给客户端，表示已经收到图像数据
            char confirmMessage[100];
            imageCount++;
            snprintf(confirmMessage, sizeof(confirmMessage), "已接收的完整图像数：%d", imageCount);
            send(ClientSocket, confirmMessage, strlen(confirmMessage), 0);
            g_imageData = imageData;

        }

        // Close the current client socket and move to the next iteration to wait for a new client connection
        closesocket(ClientSocket);
    }

    // Close the listening socket and cleanup
    closesocket(ListenSocket);
    WSACleanup();

    return 0;
}
